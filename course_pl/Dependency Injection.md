Dependency Injection
Learn the basics of NestJS, particularly through the lens of dependency injection. Create custom modules, providers, and services, and learn how to combine them in the framework to build maintainable, testable, and scalable web applications.

Get Familiar with NestJS
NestJS is an efficient and scalable back‑end framework built on Node. Used for server‑side apps or APIs or microservices, NestJS provides that efficiency and scalability with a modular engineering approach. Nest is built with modules. The root is called AppModule, and it connects a graph of all needed modules. Modules can include controllers which handle HTTP requests and responses, but the bulk of the work is performed by providers, which are often services that encapsulate business logic or data access. Because providers can be used in multiple places by various controllers or even other providers among various modules, Nest abstracts this relationship and communication complexity by using dependency injection, this design pattern separates functionality from resource management, allowing for looser coupling and better testing, as well as easier long‑term maintenance. In practical terms, this means that when you register a provider, the Nest engine handles things like instantiation, lifecycle management, and passing values to the correct functions at the correct time. Dependency injection is good engineering. In Nest, it does require using proper syntax for it to work. It's time to look at some code.

Bootstrap a NestJS App
[Autogenerated] If you haven't already, install the Nest CLI. In the terminal, I use NPM to install it globally. When that's done, I can type nest to see a list of available commands and shortcut aliases. Now I can type Nest new or just Nest N and give my app a name. I select NPM for package management, and when that's done installing, I change directories into my app folder and run the dev server. OK, it's running. In the browser at localhost 3000, I see hello world. Now, I want to see how dependency injection works in Nest. In app.service, I can see where that hello world string comes from. It's the return value of a public method of the exported apper class, which is explicitly marked as injectable by its decorator. Note that get hello is not a static method, so app service needs to be instantiated somewhere. In app.controller, that get hello method is called when there is a get request to the root route, but the controller doesn't instantiate the service. In fact, this file also exports a class declaration. This too needs to be instantiated somewhere. The app. module file imports both the controller class and the service class and exports the module class. Still, nothing is instantiated. Main dots, the launch file for a nest application, imports the app module, then bootstraps the runtime process and starts the server. So class instantiation must be handled somewhere else. It is. This is the inversion of control pattern. With it, classes stick to doing what they're built to do instead of being responsible for dependencies configurations and life cycle management. And since classes do not control the dependencies they're given, they are built to rely on abstractions instead of concrete implementations, which promotes an architecture with looser coupling, which leads to better testability, extensibility, and maintenance. In the main dottS file, the nest factory is created. This is where the dependency injection containers live, along with other systems abstracted by nests to keep it all separate from the unique needs of the application. Those needs are all compiled into the app module, defined in app.module. This module in particular imports the app controller and the app service classes into working memory, then informs the dependency injection container that they need to be given to the module. Controllers and providers are injected differently, so they're kept separate. The imports array is for importing modules. In this bootstrapped app, there are no other modules, so it's empty. The app.c controller file also imports the app service class into working memory, but it's not referenced in the controller decorator. Instead, it's a required parameter of. The Constructor method and becomes a private read only property of a controller instance. app service defined in app.service is representative of units of work. These providers are injectable dependencies. They define the building blocks of the app, and all this is managed by dependency injection within Nest. Well, as long as everything's plugged in correctly. So now I want to create a custom provider.

Providers and Services
Build a Custom Service
[Autogenerated] Providers, which are often services, are the workers of a nest application. From a bootstrapped nest app, I delete app.service, as well as references to it in the module file and in the controller file. For now, the controller returns the Hello world string directly. This, however, is business logic that should be delegated to a service. The controller should only handle HTTP requests and responses. Controllers deserve their own course. For now, I want to focus on creating a custom service provider. I call it greeting and create a greeting.service.ts file. In it, I export a greeting service class. To plug it into the Nest app, I need to make this class injectable. The decorator function is imported from the NestJS Common library. Now I can add a greet method that returns a custom greeting string. OK, in the controller, I import the greeting service class. And I want to test something. I could declare a private property and instantiate greeting service in the constructor. Which means then I can call the instances greet method when there's a get request. Does this work? I launched the dev server and opened a browser to local host 3000. It works. But this approach bypasses dependency injection and inversion of control. So, instead, I use Nest syntax to inject a private read-only property of the service, and this uh doesn't work. Nest can't resolve dependencies of the app controller. Nest can handle the instantiation of providers, but it needs an execution context or closure in which to keep it. That's what a nest module is. Providers and controllers, for that matter, have to be registered to a module so they can be running in its closure. In app.module, the app controller is already imported and registered. So now I can import the greeting service and register it as a provider. There are no errors in the terminal, and the custom greeting appears in the browser. Great. Now I want to go a little bit further. In the greeting service, I want to return JSON instead of a string, which means I need to change the return type of the greet method to, I guess I'll call it greeting. And for now, I export greeting as an interface directly from the service file. In the controller, I now need to import greeting and assign it as the return type of its get hello method. In the browser, good, it works. There's JSON. Nest handles the content type header automatically. However, you might know from experience that this source folder and its contents aren't easily scalable. I could add 10 or 100 new providers, and this would fill up in a disorganized way, and all of them registered to the same module. Luckily, Nest can help. More specifically, its CLI tool can help manage these files.

Use the NestJS CLI
[Autogenerated] I start once again with a bootstrapped app, and I have deleted all appearances of app service. It's just the app module and the app controller. This time, instead of creating a service by hand, I used the CLI tool and type nest generate service named greeting. Now I have a greeting folder. Already the app's scalability is looking better. In that folder is a spec file for unit testing, also good, and the bootstrapped greeting service file. I know I need a TypeScript interface, so within the greeting folder I create a new folder called Interfaces, and in it, a new file, greeting.interface. Then, in greeting.service, I write the public greet method and let VS Code import the greeting interface. Much better organization and scalability. Now I have to make it work with the rest of the app. Well, for the app module, I don't need to do anything. It already has a greeting service as a provider added by the CLI tool. Note that both the app controller and the greeting service now are in the same module, the same execution context. To get them to work together in app controller, I add greeting service to the constructor and VS Code adds the import. Then I declare the return type to be greeting, which VS Code also imports for me, and call greetingservice.greet, and the controller is now a consumer of the service provider. OK, I start the server and check the browser, it works. Great. But thinking about scalability, it doesn't make a lot of sense to keep adding providers to the same app module container. It's not always best practice, but a provider can have its own host module. OK, I start all over again. Here's the bootstrapped app without the app service. This time in the terminal, I type nest generate module named greeting. This gives me a greeting folder with a greeting. module file. In the app module, this new greeting module has already been imported by the CLI tool. Great, but now I need a service provider. In the terminal, I type nest generate service greeting. And the CLI tool is smart enough to assign the existing greeting module as a host container for this new greeting service. OK, now I can quickly create the greeting interface. And quickly implements the Greet method. Then in app controller, Quickly add the greeting service. So far, this is nearly the same as last time. I run the server and oops, Nest can't resolve dependencies of the app controller. There's one more step needed when working directly with a provider that has its own module. In greeting.module, I add to the decorator and exports array containing greeting service. This exposes the provider without granting access to its execution context. OK, no errors in the terminal, and the browser shows the JSO greeting. A custom provider needs to run in a module's execution context. It doesn't have to be its own custom host module, but it could be. The CLI tool helps to plug together any customizations.

Customize Providers
[Autogenerated] The greeting module registers greeting service as a provider. This provider's syntax is actually shorthand for a larger settings object. The provide property represents the dependency injection token associated with the used class property value. In this case, they happen to match, but I could create a mock greeting service useful perhaps for unit testing. This mock greeting service isn't a class, so I swap use class with use value. And the browser now shows the mocked greeting JSON. So a provider doesn't have to be a class. Here, for example, I create a Boolean testing mode variable. I can register this simple Boolean as a provider, giving it a string as an injection token, and referencing it with the use value property. Now for the greeting service. I can swap use value for U's factory, which runs a function that returns the value to be used for the greeting service token. Two things to note. First, I instantiate greeting service here, so the approach bypasses NET's automatic dependency injection, although it does allow for greater control when creating dynamic providers. Second, the use factory function itself has a dependency, testing mode. To pass it as an argument to the factory function, I have to add an inject array that includes the testing mode token. Now in the browser, the moc appears. But if I change testing mode to false, then the original greeting service appears. So the creation of providers is customizable, so is their scope. For fun, I want to add a random happy emoji to the greeting message. In the terminal, I create a new emoji service. Now I have an emoji folder with an emoji.service file. In it, I write a constructor method that sets the public emoji property to a single random emoji character. However, there's an issue. Providers have scope, and the default scope is that each is instantiated only once. It's that singleton that is used as a dependency given to every consumer. That means this randomization happens only once during the lifetime of the app. That's not exactly what I'm looking for. In this use case, what I want is for the provider to be instantiated whenever there is a new user request. So I changed this setting to scope.request. This does add a bit of an extra burden on the server. Imagine getting 100 simultaneous requests, could be 100 simultaneous instances of the service, but sometimes that might be worth it. So I plugged this request scoped service into the app. First, in the app module, I remove emojier, which was automatically registered here by the CLI tool. Instead, I want it registered in the greeting module. And now in greeting Service, I can add emoji service with a constructor-based injection and access its emoji property as part of the greeting string. In the browser, I get, well, not the emoji, but it's encoding. If I refresh, I get different values, so the request scoped service is randomizing with each request. There's another scope value, Transient, in which each consumer is given its own provider instance. But most of the time, the default scope Singleton provider works best.

Resolve Circular Dependencies
[Autogenerated] OK, another bootstrapped app this timekeeping app Service, and I've already added a greeting service using the Nest CLI. In app Service, I use constructor-based injection to add greeting service as a dependency. The GHo method just returns the value of the greetinger's GHo method. Note that there is a public greet string here currently unused. Greeting service looks very similar. It also has a public greet string, but it's Git hello method returns both its own greet string as well as the one from app Service. And here's the constructor-based injection to add app service as a dependency. This is circular dependency. The two services require each other, making dependency injection impossible. You probably want to avoid circular dependency as much as possible, but in the real world, you might find that something like a user module and an off module could depend on each other. Luckily, there is a solution. In the terminal, the error seems to be in greeting service. So, in grading service, I can manually control the sequencing of dependency injection with the inject decorator and forward ref to add a function down the stack that returns the needed dependency injection token. Now there are no errors in the terminal, and the browser shows both hello messages. In some cases you might need to use forward ref for each consumer in the circle, not just for one, but here it worked. Again, it might be best to avoid circular dependencies whenever possible.

Custom Modules
Import ConfigModule
[Autogenerated] Modules in NSJS are the containers for your app's features, data, logic, and configuration. That last one, configuration is what I want to look at. As before, I start with a new app and remove all references to app service. But now I install something else. In the terminal, I add NEJS config as an application dependency. This allows me to use environment variables for my app, always a good idea. So I create a dot ENV file in the root folder. And add a default user, me, and a default greeting, hello. In app module, I import Nest's config module and add it to the module decorator's imports array. However, config module is special. It's a dynamic module. To add it to app module, I need to call it static for root method. It's not required, but I also pass in an options object with is Global set to true. Now, config module is available everywhere in the app without needing to import it into every module that uses it. So now I create a module that uses it, and then a service for that module. In greeting module, I make sure that greeting service is registered as a provider, which it is, then I add it as an export. If the config weren't global, I'd have to import it here. In grading service, I use constructor-based injection to add config service as a dependency. Then I create a get hello method that uses the config services get method to access configuration variables. Here I could directly access these variables from the process. ENV object, but the config service can hold other values, so I show the use of its get method. Now, in app Controller, I put the new service to work. Constructor-based injection. And call the get hello method. OK, time to test it all out. Run the server, no errors, that's good. And the browser, greets me. Success. Nest's config module allows for much greater customization, and configuration deserves its own course, but it also demonstrates there's more to learn about dynamic modules.

Create a Dynamic Module
[Autogenerated] OK, here's another bootstrapped app without app service. I also install NestJS config. In app module, I import config module and call it static factory method for root. This enables access to environment variables, which I use for my own dynamic module, which I install with the CLI. OK, in the new greeting module, I add a static for root method that must return a dynamic module. VS Code automatically imports it for me. At minimum, this for root method must return an object with a module property set to a class, most often the current module class. In the app module, the CLI has already added greeting module to the import array, but now I can call it static for root method. For root is a customary name. You can use whatever you want, but for root is good because it implies the dynamic module is to be created once at root level. You might come across a register method or for feature, which imply other meanings. I start the server, no errors. OK, I can keep working. Back in greeting module. Now, the benefit of creating a dynamic module is that it can change based on settings, and it can change its content as well. Here I configure a dynamic provider value dependent on a node ENV setting and define a dynamic greeting service with an injection token and one of two values. Then I return these dynamic provider options in both the providers and exports arrays, along with the optional global setting. Since scalability is a theme for this course, there's one more thing I want to do before continuing. The dynamic greeting service can be imported by consumers through its token, so I want to define that token in another file. In the greeting folder, I create a constant dots file and export a new token constant. It's just exporting a string value, which is fine, but I can improve scalability and avoid future conflicts by making this a symbol. Then, back in greeting module, I replace the token string with the imported token constant, much better. OK, now I can use it elsewhere in the app. In app controller, this constructor-based injection needs a type. Right. The greeting service value is a string. OK, good so far, but this syntax won't work with a dynamic service. What I need to do instead is use the inject decorator and pass in the greeting token. This gives me access to the dynamic service value, which I can return from the get hello method. OK, I check the browser. Good, that's the default. Now I create the dot ENV file. And I set Node ENV to production. Refresh the browser and I get the new text string. In dot EMV, I changed the value to development. And the text has changed again. Dynamic modules are powerful and flexible because they can respond to the application environment.

Let NestJS Build a Dynamic Module
[Autogenerated] Last time, I promise, here's a new bootstrapped app without the app service. I installed the Nest JS config library, as well as generate a greeting module and a greeting service. In app module, I add config module to the imports array and call it static for root method. Now, I'd love to do the same thing for greeting module and pass in some options object that defines the dynamic module, like this. Of course, VS Code informs me that for root does not exist on the greeting module class. I'll get to that, and there's more to take into consideration. Luckily, Nest provides a configurable module builder that abstracts much of creating a dynamic module. In the greeting folder, I create an interfaces folder, and then a greeting. module options file. I need to export the shape of the options object to be passed into the for root method. Then, in the greeting folder, I create a greeting. module definition file. And import both the greeting module options I just created and Nest's configurable module builder class. This should help. I can instantiate the configural module builder with the abstract interface, then call its build method. Actually, this sets the greeting module's static method to register by default, so I can set the class method name to for root and then call build. And all of this has a return value, an object with two useful properties that I can destructure and export configurable module class and module options token. I can extend the configurable module class to create my own dynamic module, add that to my to do list, and the module options token is an injection token pointing to whatever options object is passed into the for root method. I can use that to make greeting service dynamic too, but I don't want these names to conflict with any future dynamic modules, so I rename them before exporting. OK, first, in greeting.module, I add greeting service to an exports array. But more importantly, this greeting module can extend greeting configurable module class. Now, I can add a static for root method. Oh wait, I don't have to. That's already part of the greeting configurable module class. So, I guess I'm done with this file. Notice in app module that the greeting module for root method is no longer marked as an error. Good. Next, greeting service. In the constructor, I can inject the greeting module options token. Then I have to do something with this options object. I create a public greet property and in the constructor assign it a value depending on options.tv. And now I'm done with this file. In app controller, I use constructor-based injection to add greeting service, and then return its greet property for the get request. And that's it. I just have to test it. Start the server, check the browser, that's the default text because I don't have a dot EMV file yet. So I create one and set node EMV to production. And hello from production. Change Node ENV to development and hello from development. Nest's configurable module builder does seem to streamline the process of creating dynamic modules as host containers for dynamic providers.

App Design and Development
Plan a NestJS App
Time to put this all together and build an application. The NestJS syntax can be daunting. With practice, it gets easier. I want to try creating a simple demo app. The goal is a tool that calculates the similarity or distance of two words. The closer the words are to each other, the smaller the distance. This is useful for data cleaning or clustering or for autocorrect algorithms. I've written some code to calculate this word distance. This isn't the important part. Know that it works, but it's certainly not the best or fastest implementation. In fact, I want the app to allow for other implementations submitted by different contributors, keeping the app flexible. Only one algorithm can be used at a time, so I need a configuration to load the correct one, and that sounds like a good use case for a dynamic module and service. I want to use the configurable module builder for this, and I need a feature module with a controller that allows user interaction. It's just one Get request with the two words as variable parameters. Finally, the app should be well organized, planning for easier maintenance and scalability. I think I can do this. Are you ready?

Scaffold the App
Time to get started. In the terminal, and I'm on a Windows machine, I create a folder with my app name worddist and change directories. Now I use Nest to create my app using the name of the current directory. When that's done, I need, well, I know I can install config. I need a dynamic module and service to get the current algorithm. I install the module first and call it algo, then the service, which is automatically hosted by the module of the same name. Now the feature module, I call it getdist, and this needs its own controller, which is also automatically hosted by the module of the same name, and I'm pretty sure both modules need interface subfolders. What else? I need an env file and a contributor's folder. In that, I add a folder for myself and one for my buddy, Carlo. Okay, here's what the project looks like at the moment. I went ahead and put my getDistance file in my contributor folder, and for testing, I added one to Carlo's folder. This function just returns 1234. To make sure nothing's broken yet, I start the server. In another terminal, I send a quick curl request to localhost:3000, Hello world. Everything's working so far. Great. What would you do next?

Build the Feature Module
[Autogenerated] I have to start somewhere. I think it's the feature module. In app.module, I can see that my feature module, GDed, is imported and hosted. Good. In Git disk dot module, the controller is imported and hosted. I don't need to do anything with this file. Gitist dotcontroller, however, needs some work. It controls the slashitist route, but there's no request handling yet. I start with a get decorator and VS Code imports what I need, and I define a get dis method that for now, returns a hello string. Quick test to make sure this works. It does. Good. Now I need the user to be able to supply two words as variable parameters. I call them A and B. And I can access these with the Peram decorator. Another quick test. All good. But I want to return a JSON objects, so I need to define an interface. In the interfaces folder, I create a distance.tinterface file. Then in the controller, I amend the Git dis method to return a distance interface, and I rewrite the return value with a hard coded number for now. And the route works. Good. Now, getting a real number for the word distance is for the next couple of steps.

Add Configuration
[Autogenerated] In app.module, I can add to imports the config module. You might remember I need to call its static for root method so that the EMV file is read by the app. Now I need a way to export contributors' code. So in the contributor's folder, I create a contributors.ts file. I import the code contributions by name and export an object. The next step is to create the dynamic module.

Create the Dynamic Module
[Autogenerated] Right away, I know I need an interface called algo.module options. This defines what makes this module dynamic, and I only need one option, contributor. I also need a module definition that implements the configurable module builder. This file seems to be pretty standard, which is good. That's the point of letting Nest build a dynamic module. I do want to rename the static class method name, however, as well as the destructured variables for readability and so that they don't conflict with any future dynamic modules. OK, in algo dot module, this class needs to extend the algo configurable module class, done. And in Algo dotService, the constructor needs to inject the algo module options token as an algo module options interface. This might be a good time to add another interface for the algorithm function itself, which takes in two strings and returns a number. Good. Now I can use this back in the algo service, create a private algorithm property, and give it a value in the constructor from the contributor's object. Now, for the actual service, I add a get distance method that uses this algorithm. One more step to go, put it all together and test it out.

Put It All Together
[Autogenerated] Right now, the two modules are not communicating. Time to fix that. The first thing I want to do in Algo module is to make this a global module, which makes this available throughout the app. It's not required, but it might make some sense here. Next, I export Algo service from this module, so I can import it in the Git disk controller. I use constructor-based injection to access the Algo service. And now, finally, I can replace the hard coded number with a call to an actual algorithm. Lastly, way back in app module, I call the static for root method of the algo module, passing in the contributor from the ENV file. OK, time to test it. The servers running, no errors. In another terminal, I use curl and get a good accurate response. Great, this works. Now, I can give Carlo a chance. And I send the same request and get back 1234. Everything's working. From here, there are so many apps to build with Nest JS, large and small. Good luck with all your Nest JS adventures. Thanks and happy coding.
