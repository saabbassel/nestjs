# Introduction to Middleware
Managing tasks like logging and response formatting is an important part of building applications. In this course, NestJS: Middleware and Interceptors, you’ll learn to use middleware and interceptors to handle these common tasks. First, you’ll explore how to set up middleware to process requests before they reach your controllers. Next, you’ll discover how to use interceptors to modify responses and log important data after a request is handled. Finally, you’ll learn how to apply middleware and interceptors at different levels of your application for better organization and efficiency. When you’re finished with this course, you’ll have the skills and knowledge of NestJS middleware and interceptors needed to build clean and maintainable applications.

# Intro to Middleware and Interceptors
Hello and welcome. I'm Treasure Porth, and this is a course on NestJS middleware and interceptors. Middleware and interceptors are both processing layers that help you manage cross‑cutting concerns. Cross‑cutting concerns are functionalities needed across your application, such as logging, data transformation, data validation, authentication and authorization, and error handling. One of the main differences between middleware and interceptors is when they're executed. Middleware functions are called before a request reaches a route handler. This makes middleware great for tasks that need to occur earlier in the request response cycle, such as logging incoming requests, transforming incoming requests like parsing the request body, validating incoming request data, and authentication like verifying JWT tokens or API key. Interceptors, on the other hand, have access to a request both before and after the request is processed by the route handler. So interceptors are good for tasks like measuring and logging response times for performance monitoring, transforming response data, like wrapping responses in a standardized format, or attaching metadata like timestamps or custom headers. And interceptors are also good for handling and formatting some types of errors globally, like transforming exceptions into user‑friendly formats or logging errors. In this course, you'll learn how to implement middleware and interceptors via some common use cases. So let's get started.

# Create Middleware
Let's create a piece of middleware that logs helpful information about incoming requests. I'm starting out here with a basic NestJS app generated with nest new. Open a terminal and create middleware with the Nest CLI command nest generate middleware logger. Let's take a look at the file that's generated. Our goal with this middleware is to log to the console the request method, like get, post, delete, etc., along with the requested route. To log this information, we need to access the request object from our middleware. Middleware in NestJS implements the Nest Middleware interface, which requires defining a use method. The use method provides access to the request and response objects, so you can modify requests, handle authentication, log data, or anything else you want to do with your middleware before passing control to the next handler. Nest tries to be pretty flexible here about what you use in the middleware to access the request and response objects. So it's set up to support Express by default, but you could also use Fastify or something like that. We'll go ahead and use Express. So import Request, Response, and Next from Express, and then we'll have access to these functions from inside the custom middleware. Console log the HTTP request method and the URL. We've written a simple middleware. Now let's implement it. In app.module, import the logger middleware. Modules that use middleware must implement NestModule to gain access to the configure method. When you implement NestModule, it automatically passes a helper class called MiddlewareConsumer to the configure method. On consumer, we can use the apply and forRoutes methods. The apply method is where you register your middlewares. Go ahead and register the logger middleware. In the apply method, you can list multiple middlewares. So I could add another middleware, and these will execute sequentially in the order that you list them. In forRoutes, specify which routes should trigger the middleware to execute. For now, apply logger middleware to all routes using a wildcard. So this configuration says that when a request is made to any route in my entire application, apply the logger middleware. Start your server and make a request to your home route. To do this, I'm going to use a VS Code extension called Rapid API, but feel free to use whatever client you're comfortable with. If the middleware is set up correctly, you'll see a log in your console for a get request to the root route.

# Include and Exclude Applied Middleware Routes
There's quite a bit of refining and fine‑tuning you can do in the middleware configuration. For example, you can restrict middleware to certain routes or certain request types. Instead of a string passing in a wildcard here, we can pass an object to forRoutes defining a path and which HTTP request should trigger the middleware. This route will execute middleware only when a client makes a post request to /users. You can also bind middleware to a specific controller. To apply middleware to multiple routes, you can list any combination of controllers and objects in the forRoutes method. You can match characters in a route with route wildcards. This route will execute middleware for any request type and to any route prefixed with /users. You can also exclude routes using the exclude method on the middleware consumer. To exclude, you can pass one or multiple strings, controllers, as well as objects.

# Create Functional Middleware
Middleware doesn't always need to be a class. Our logger is a very simple middleware with no dependencies and so could be converted to functional middleware, which is very much what it sounds like, a function instead of a class. So instead of exporting a class, export a function. Change the class name to a function name. We'll no longer implement NestMiddleware or the use function, so pass Request, Response, and NextFunction directly to the logger function. Then, res.on finish will run a callback that console logs the request method, the URL, and let's also include the response status code, as well as the status message. We can no longer use dependency injection here. This is fine because our logger doesn't need to access anything externally. But say, for example, our logger used a service to save logs to a database. Any middleware that needs to access services, shared logic, or config information inside middleware should use a middleware class. We'll also need to call the next function here. And in app.module, replace the LoggerMiddleware class with the logger functional middleware. Send some requests to the server, and this is hanging because we need the next function to be outside of res.on. So let's try this again, and we're successfully logging requests. You can also register functional middleware globally. In app.module, let's comment this out and reset the app.module export. Then, in main.ts, just after the line where the app is created, we can use app.use and pass the logger middleware. Let's also import the logger and send a request. And you'll see that works just the same.

# Introduction to Interceptors
Intro to Interceptors
Hello and welcome. Let's talk about NestJS interceptors. Interceptors have access to the request and response objects before the request hits the route handler and after the route handler is executed. This makes interceptors particularly useful for measuring and logging response times for performance monitoring, transforming response data like wrapping responses in a standardized format, and modifying requests before processing, like automatically attaching metadata. In this part of the course, we'll implement a logger that logs request execution times. But first, let's get familiar with the syntax of an interceptor with a quick example. The initial NestJS project structure generated by nest new comes with an app controller with one get method, getHello. GetHello calls a service which returns the string Hello World. This is an example of an interceptor that intercepts the response Hello World and changes the string to Hello, planet before it's sent back to the client. Let's break it down. Interceptor is decorated with the Injectable decorator, marking it as a provider that can be used globally or imported into controllers. The Interceptor class implements NestInterceptor, which gives us access to the intercept method. Intercept makes two classes available, ExecutionContext and the CallHandler. ExecutionContext is what provides us access to the request and response objects. This example isn't using ExecutionContext, but we'll cover it a little later. Next.handle calls the controller method. So it will call the getHello method and wrap its return value, which is Hello, world, in an observable. If you're not familiar with observables, think of them as a wrapper around the response that lets us work with the response's value instead of returning it immediately. Pipe allows you to use RxJS operators to log or modify the response object. Inside pipe, we can use the RxJS operator map to replace the response with the string Hello, planet before the response is sent back to the client. To quickly recap, an interceptor intercepts both the request and the response data, running before and after the route handler processes the request. It acts as a middleware‑like layer, giving you a chance to perform operations before the route method is executed. The interceptor then calls the route method capturing its result, which you can modify before sending it back to the client. After the route method executes, you can use RxJS operators inside pipe, such as map to transform responses, or here you see tap, which is used to log response details. That's an interceptor broken down. Now let's go ahead and build one.

# Build a Logging Interceptor
Let's create an interceptor for a simple logger, which calculates and logs the request execution time, in other words how long it takes to send a response to a client after a request is received. I'm starting with the NestJS project generated by the Nest CLI. Let's use the Nest CLI to create an interceptor. Open a terminal and use the command nest generate, or g for short, interceptor logger. Now let's talk about the ExecutionContext. The ExecutionContext enables you to access the request and response objects. Interceptors enable you to work with a variety of execution contexts like WebSockets and GraphQL, for example. So we need to explicitly access the HTTP context here. We can access the request and response objects using a method on context called switchToHttp. This is how you indicate you want to work specifically with the HTTP request and response objects. To return .handle, add a pipe. And in the last example, we used map to modify the response, but this logger will only log data. So we use the RxJS tap operator to log a string. In the string, log the request method, the URL, and the response execution time. Let's import tap from RxJS. To calculate the response duration, we'll need to get the time before the route handler was executed and the time after the route handler was executed. First, save the time outside of the observable, in other words before the route handler executes. We can get that time by calling Date.now and saving it to a variable called now. Inside of tap's callback function, which runs after the route handler has executed and just before the response is sent back to the client, let's save the time again. Then we can subtract the two to get the response duration. This request is going to finish fairly instantly, so let's manufacture some slower network conditions. Use an RxJS operator called delay to slow down the response time so that we can really see it. Delay taps execution time by 500 ms. Let's also set a custom header that sends the response time back to the client. Providing the response time to the client can be helpful for performance optimization and debugging. We already have access to the response object via ExecutionContext. Use the method setHeader to add the response time to a header called X‑Response‑Time. Now we need to register the interceptor to a controller or a specific route. To bind the interceptor at the controller level, let's go to app.controller and import the class UseInterceptors from nestjs/common. We'll also need to import the logger interceptor that we just created. To use interceptors, we can pass the logger interceptor, placing it just above the controller we want to bind it to. Start your server and send a request. After a short delay, it should log that there was a get request to the root route, and it took 500 and something milliseconds. Also take a look at the headers, and you'll see the custom header we added.

# Interceptor Scope
We've seen how to bind an interceptor at the controller level. You can also apply interceptors to specific routes or register them globally to affect all requests across your application. To bind an interceptor to a specific method, place UseInterceptors just above the method. Send a request. And you'll see that it works just the same, only now it applies to just this specific route handler. Let's comment this out for now. You can bind an interceptor globally in main.js by passing a new instance of the interceptor to app.use. However, the downside of binding an interceptor globally is that you lose access to dependency injection. This isn't a problem for our LoggerInterceptor because it doesn't need to access any external services. But what if it did? For example, let's say the LoggerInterceptor was extracting request details and passing them to a logger service, which was saving logs to a database, an external logging system, or some other storage. The global interceptor approach wouldn't work here because the interceptor doesn't have access to NestJS dependency injection, meaning in order to use the logger service, we'd have to manually instantiate it inside of the LoggerInterceptor, which isn't ideal and can get messy fast. Instead, let's register the interceptor at the module level so dependency injection stays intact. I'll go ahead and get rid of this. And in app.module, we'll add an object to the providers array telling NestJS to use LoggerInterceptor as an app‑wide interceptor. Let's send a request, and it should be working just the same.
