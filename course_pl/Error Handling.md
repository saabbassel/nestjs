# Error Handling
Building scalable and resilient applications requires a solid understanding of error handling and testing. In this course, NestJS: Error Handling and Testing, you’ll gain the skills to create robust applications with effective error management and testing strategies. First, you’ll explore how to implement global error handling and create custom exception filters in NestJS. Next, you’ll discover how to write unit tests and end-to-end tests to ensure application stability. Finally, you’ll learn test-driven development approaches and best practices to enhance your testing workflow. When you’re finished with this course, you’ll have the knowledge and skills to effectively debug, test, and maintain NestJS applications.

# Explore NestJS Defaults
Error handling and testing are standard tasks in any NestJS application. I want to start with error handling. Specifically, I want to start by taking a look at what resources NestJS provides by default. Here's a boilerplate NestJS app created from the CLI tool, and I start up the server. Using the Rapid API extension for VS Code, I can send a get request to localhost 3000 and get back Hello World! But now, in the AppController's getHello method, I force an error. When I send a new get request, the response is a 500 internal server error, and the server terminal logs my custom error message. But I can send the request again. I get the same result, but the app hasn't stopped running, even when an unspecified error is thrown. This is the NestJS exception layer at work, catching all unhandled errors and exceptions in the application, which is great, but there are resources that allow for more control. Instead of throwing a generic error, I can use Nest's HttpException class to provide more specific information to the user, in this case, Gone, which has its own status code, 410. Instead of hardcoding this status though, I can use Nest's HttpStatus enum, and that reliably works. I can even expand the first argument into an object with additional properties if I want. And now the extra information is sent to the client. In fact, Nest is way ahead of me. It already has a GoneException class that does what I'm trying to do. So, with less effort, I achieve the same thing. Nest has a built‑in collection of the most common HTTP exceptions. In most cases, perhaps, these defaults provide enough error handling for your app. But sometimes, you have to customize.

# Customize Exception Handling
I want to create a custom HTTP exception. In a new exceptions folder, I create a custom‑gone exception file. In it, I export a CustomGoneException class that extends Nest's HTTP exception. Its constructor takes an optional message string, then instantiates the parent class with the message and HttpStatus GONE. In the AppController, I can now throw my new CustomGoneException with an overriding message and then send a get request. The response is 410 Gone with my message. I can even expand upon my CustomGoneException class with more information. And now a get request responds with more detail. Great, now I just need to customize every other possible HTTP exception. Or I can create a custom exception filter, which gives me more control over Nest's exception layer. I create a new file for my custom‑httpexception filter. In it, I export a class that implements Nest's ExceptionFilter interface. This needs a Catch decorator to specify what this filter intends to handle. This one handles HTTP exceptions. If I leave the Catch decorator empty, then all errors and exceptions filter here. But in this case, I allow Nest's exception layer to handle everything but HTTP exceptions. To satisfy the ExceptionFilter interface, I need a catch method that takes two parameters, the exception itself and the host, a NestJS wrapper around its HTTP server. By default, it's Express. From the host, I can access classes direct directly from Express, specifically Request and Response. I can also get the status, message, and name from the HTTP exception. And now I can build on the response as I would in a plain Express app, sending JSON to the client. In AppController, I can add another decorator to the get route, UseFilters, and add my CustomHttpExceptionFilter to it. I also revert to throwing Nest's GoneException. Now, when I send the request, I get back everything defined in the custom filter. Good. Back in the AppController, I can apply this filter to all routes by moving the UseFilters decorator to the top. And when I send the request, the response is the same as before.

# Go Global
Now, I want to catch anything anywhere. So I duplicate the filter I've written and name it CustomExceptionFilter. I can amend this to globally handle errors and exceptions by, first, emptying the Catch decorator and then changing the exception parameter type to just Error. Because I don't know exactly what kind of error I'm dealing with, I have to have some kind of decision logic. I keep it simple and isolate HTTP exceptions from other errors, for which I send a 500 Internal Server Error. Okay, now I have to tell the app to use it. In main.ts, I use global filters and provide an instance of my CustomExceptionFilter. In the AppController, I comment out the UseFilters decorator. Now, only my CustomExceptionFilter is active. Okay, I send a get request, and the response is 410 Gone with the extra information. It worked for an HTTP exception. Back in the controller, I proceed to the Gone exception with a new error, and my CustomExceptionFilter catches that too. There's another huge benefit to using your own exception filter. In the app module, I add a new provider, Logger. Then, in main.ts, I can access that logger and inject it as a dependency of the CustomExceptionFilter, which, in its file, can accept that logger in its constructor. Now I have a way to log every error or exception for my app. Okay, I send the request and get the same response as before. But in the terminal, I also see the error log, and now my app globally handles all errors.

# Testing
Get Started with Testing in NestJS
Automate testing for your NestJS app with the Jest and Supertest libraries. Testing is essential, and there are tools that come packaged with Nest. Here's a starter app created from the CLI. In the src folder, there's a spec file. That naming convention is necessary for the testing engine to discover these files, and it's good practice to put spec files in the same folder as the file it tests. Also, there's a separate test folder for application‑wide end‑to‑end tests. Okay, I want to dive in and see what's automatically provided. In the terminal, I can run tests, one file, one suite, one test, which passes. How about end‑to‑end tests? And that's a different test, which also passes. But while I'm exploring, I want to look at test coverage. I run test cov and, well, it's not 100%, which leads me to wonder what good testing means. Very briefly, some good advice includes planning or creating a policy that predetermines the extent of testing needed. Shifting left suggests that testing begin earlier in the development lifecycle and continue throughout. In fact, testing could even come before writing each chunk of code, as with test‑driven development. Also, test quality is important. Be sure you're testing what you think you're testing. Coverage usually does not need to be 100%, but it is necessary that all business logic is thoroughly tested. And embrace automated testing. Okay, take a look at the AppController test file. This is Jest syntax. The describe function groups related setup and tests, and it could be nested for better organization. The it function represents one test, while expect and toBe represents the assertion for the test. In this case, a getHello call on the AppController is expected to return the string Hello World. What I find more interesting is this Jest beforeEach function. In it is Nest‑provided functionality, which instantiates a test module, separate from the app but compiled from app dependencies, in this case the AppController and the AppService. It exposes the AppController for testing, and Jest's beforeEach does this before each test. Now I'm excited to write a new test. For now, I use some test‑driven development principles and create tests first before writing production code. This is a test for a new route, /test. And for the test itself, it should also return a string. And I expect a call to the AppController's getTest method to be exactly that string. And of course, the test fails. Property getTest does not exist on type AppController. With test‑driven development, this is a good thing because the test results can now guide me. In the AppController file, I add the new getTest method that returns the string I'm looking for. Now I run the test again, and it passes. Good, but I'm not done. TDD is an iterative process, red, green, refractor. The test failed, red, then it passed, green, and now I'm at the refactor stage. The controller should probably defer business logic to the service, which, of course, puts me in the red phase again. Property getTest does not exist on type AppService. Okay, in AppService, I add getTest, and now the tests pass again, green. To be thorough, I want to look at the end‑to‑end test. Here's the now familiar describe and beforeEach functions from Jest. But inside it, the Nest testing setup is a little different. This recreates an entire Nest application in a testing module and initializes all controllers and providers, so they are available for true end‑to‑end application testing. Also, there's an import from supertest. Here it's used to send a simulated HTTP request to the root route, expecting a 200 OK and the Hello World string. Okay, I can duplicate this entire test and change the route and the expected return string. And the test fails, red. Expected 200 OK, got 404 Not Found. I can fix that in the AppController. I add the Get decorator and the route for the getTest method. Try again, and the E2E tests pass, green. Good. Lastly, I get a coverage report. Still not 100%, except where it's critically important. All business logic in the AppController and AppService is fully covered, and there's a new coverage folder with test reports. Okay, great. But how about testing a more complex application?

# Write Controller Unit Tests
I start small with isolated unit tests. Here's the app, a quote API. With the right authorization header, a user has crud access to a PostgreSQL database. It's working as expected. This controller file is common. It does nothing out of the ordinary. Okay, here's the autogenerated controller test file. This is also ordinary. It has one test, expect controller toBeDefined. I run a test just for this quote controller, and it failed. Nest can't resolve dependencies of the quote service. I'm not even testing the quote service. An important part of unit testing is to isolate what you're testing. In this case, I don't want whatever is going on with quote service to affect tests for quote controller, so I get rid of it. Or rather, I can replace it with something else. For this test, the quote service injection token points to an empty object. Now if I run the test, it passes. Well, this one test passes. Controller is defined. Now I need tests for all of these methods. I skip each, so I can work on them one at a time. Before that though, I need some test data. Here's a quote that I can work with just for testing purposes. I start with create. Okay, it should create a quote, and I expect the create method to return an object with an ID. I don't know exactly what ID it will be, but I can expect it to be a number. Jest allows for this. Also, the returned object should have all properties and values of the test quote. I run the test, and it fails. This quote service create is not a function. That's because I replaced the quote service with an empty object. There's no create method on it. I'm going to have to create a mock service implementation. So, I create a mockQuoteService object and use that as the value for quote service. Now the mock service needs a create method. I set it to a Jest function that takes a DTO and returns an object with an ID and all the properties of that DTO. For the ID, any number will do. I use Date now. I run the test, and it passes. I want to point out that the expected return from the controller is exactly what I'm returning from the mock service. So, what's actually being tested here? That the controller is calling the service create method. It might seem small, perhaps, but small things tend to get overlooked when not tested properly. The remaining tests are very similar, but I do one more, update. Here's an implementation for the mock sevice. And here's a test, which, again, in this case, really is just testing that the controller is passing logic on to the service. And the controller tests all pass.

# Write Service Unit Tests
Now, what's going on with the quote service? I run a test, and it fails. Nest can't resolve dependency. Ah, it's missing a quote repository. The one I use is from TypeORM. I might need to mock this dependency too. I don't really want my unit tests to access the database. So instead, I get the quote repository token from TypeORM and change its value to a mockRepository. And now the test passes, one test that the service is defined. But all these methods also need to be tested. And here's a new test quote, this time with an ID. I want to start with the quote service's findAll method, which just calls the repository's find method. Using what I've learned from testing the controller, I can add a find method to that mockRepository that returns an array and then write the test that ensures the service calls the repository. And the test passes. But the quote service findOne method is a little more interesting. First, it's asynchronous. Second, it does one of two things depending on the repository's findOneBy method. It could return a quote or throw an exception. Both need to be tested. So, in the test file, I write a mock implementation using Jest's fn method. The function is asynchronous, destructures ID from the object argument, throws a Not Found Exception if the ID is invalid, or otherwise returns a promise with testQuote as a resolve value. Now for the tests. I need two of them, but I'll do the second one later. First, the positive outcome, which is an async function, and that works so far. Now, for the negative outcome. I try to find a quote with an ID I know doesn't exist. Then I need just to catch the exception and ensure it's a Not Found Exception. Okay and this also works. Great. Now, looking at the service file again, I can see that update also can throw an exception. But if I look closely, remove can too. The service calls its own findOne method from remove. Okay, I want to write a test for remove. So in the test file, I can add to the mockRepository a remove method that returns the quote it receives. And the tests are nearly identical to the ones I just wrote. But instead of findOne, I call the remove method, and these tests also pass. There are more unit tests to write, but it's time to take a look at testing more of the app.

# Write Integration Tests
So now I want to make sure the controller and the service work together. Nest's E2E test file can help with that. But I want to rename this file to quote.e2e‑spec because I'm not testing the entire app. The database component needs a special consideration in an end‑to‑end test, and it's not uncommon for it to be left out. For now, I want to isolate the integration of the QuoteController and the QuoteService, which comes pretty close to testing the entire app end to end. Be wary, by the way, that you might need to fix the automatic import. It might need to go up a level in order to find the app folder. Okay, now back to the integration. I'm not testing a database, so I use a mock implementation for the QuoteRepository, and I can use this mockRepository. A different database might have a different implementation. Of course, I also need a test quote. This one has a predefined ID property. Then I get rid of the default test and create a describe block for quote routes. And the first thing I want to test is authorization with these two tests. My app uses a simple guard that checks the request's authorization header value against an env variable stored in my .env file. So I start with some negative testing, in which I try to generate errors from user input. I use Supertest to build a request from the app's HTTP server, send a get to the /quote route without authorization, and expect a 403 server code. Now I can run the test with npm, and it failed. Expected 403 Forbidden, got 200 OK. For an integration or end‑to‑end test, you want to be as close to the actual app as possible. And I missed a step. In main.ts, I use global guards for the real app, but the guard is not applied to the test app. Additionally, I use global pipes, which are also ignored in the test app. Okay, I copy all of this. And in the E2E test file, I paste it in and update the imports. Now the test app is a lot closer to the real one. I also need access to that API key, so I add to the testing module an import, ConfigModule, for root. I run the test again, and this time it passes. Good. For this second test, I set an authorization header to an invalid value, and both tests pass. Now I can test the first route, a get request to /quote. Note that I set the authorization header to the proper API key. Everything passes, all green. Okay, I want to speed up a bit. Here's a test for the post request that sends JSON to the server and expects 201 Created. There are two get by ID tests, one for a valid ID and one for an invalid ID. The second one is asynchronous and uses a try catch statement to await the request, but handle the expected error. The syntax here is finicky. If I omit the await operator, then the test hangs. And if I return the response, then, if the request somehow succeeds, I'll have a false positive. Not good. Okay, the patch tests are very similar, but these use an updated quote to replace the old one, and the delete tests are also very similar. Okay, here we go. I run the tests, and everything passes.

# Write End-to-end Tests
Now I want to take this one final step. I want to add the database into the end‑to‑end test. In my case, I'm using TypeORM and PostgreSQL. But whatever database technology you're using, it's important to keep testing separate from application data. I duplicate the quote.e2e‑spec file and name it app.e2e‑spec since this file is intended to test the entire app end to end. But there are some changes needed. First, I get rid of the mockRepository. I'm not mocking anything in this file. And I make a testQuote and updatedQuote available to all tests. Okay, in createTestingModule, I don't need the mockRepository provider. In fact, I don't need the separate QuoteService and QuoteController anymore. I can just import the entire QuoteModule. But I do need another import, TypeOrmModule. Here I set up credentials for a database I use only for testing. I allow TypeORM to load the entities it finds, but I disable synchronization. Consider running tests on a port different from an app in production. Now my tests should be connected to the database. But it's not necessary to reconnect before each test, so I change this Jest method to beforeAll. Also, I now need some tear down. I add afterAll to the testing lifecycle in order to shut down the app, which also closes the database connection. As for the tests themselves, they're mostly the same, but I rearrange a bit. I put create first, for example, to better deal with data that persists throughout all of these tests. I make the idea of the newly saved quote available to the other tests. I use Jest and Supertest a bit more to isolate properties. And at the end, I remove the test quote to keep the testing database clean. Now it's time, and everything passes. Good. That's end to end from simulated user input to the database and back again. Good luck with all your error handling and testing with NestJS. Thanks for joining me and happy coding.
