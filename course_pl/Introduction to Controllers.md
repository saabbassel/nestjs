# Introduction to Controllers
Building and managing APIs can be complex without a clear structure. In this course, NestJS: Controllers and Routing, you’ll learn to create well-structured API endpoints. First, you’ll explore setting up controllers and routing. Next, you’ll discover how to handle requests and responses effectively. Finally, you’ll learn how to implement validation and DTOs for reliable API design. When you’re finished with this course, you’ll have the skills and knowledge of NestJS controllers and routing needed to to build maintainable and efficient APIs.

# Intro to Controllers
Hello and welcome to NestJS: Controllers and Routing. Let's talk about how you can use NestJS to more quickly build a secure, well‑structured, and maintainable REST API. Within a NestJS module, a controller is responsible for handling requests to your API and sending back appropriate responses. Here we have a basic NestJS app. If you haven't already, download the provided exercise files or install the Nest CLI to quickly scaffold a NestJS application. You can install the CLI by opening up a terminal and using the command npm install g @nestjs/cli. Create a new NestJS application with the command nest new and whatever your desired application name is. Take a look inside the src folder at app.controller. You establish a controller with the Controller decorator. The controller is what enables the decorator to handle HTTP requests and allows you to map methods to routes. You can pass a Controller decorator an argument to specify a route prefix. For example, if you were to pass the string api into the Controller decorator, now all the handlers in this controller will respond to routes prefixed with /api. Inside the Controller class, you add methods to define how to handle different route paths. Each route handler is annotated with the decorator that corresponds with an HTTP verb. So we know this handler responds to a get request. And when a get request is made to this path, the getHello method is called. Controllers generally delegate an application's business logic to a service. So when a client sends a get request to this path, the controller calls the getHello service. Take a look at app.service. It's pretty straightforward. It returns the string Hello World. Go ahead and run your server just to confirm that everything is working. You can start your server with the command npm run start:dev. As my client, I'm going to use a VS Code extension called Rapid API, but feel free to use Postman or whatever else you're comfortable with. Send a get request to your application. We get that Hello World response, which means the application is up and running. Throughout this course, you'll flesh out a feature for a conference management application, specifically a module that's responsible for enabling a client to get, create, update, and delete conference speakers. Get started by creating a SpeakersModule and a SpeakersController. You can use the CLI first to create a module. So I'll shut down my server, and you can create a new module with nest generate, or nest g for short, module plus the name of the module you want to create. So I'm going to name this module speakers. Take a look at your file structure, and you'll see that a new folder called speakers was created with a file called speakers.module inside. To create a controller, use the command nest generate controller, plus whatever you want to name your controller, so I'm going to call the controller speakers as well. Now in the speakers folder, you should have a file called controller. Nest also automatically creates a spec file for writing tests, which we're not going to worry about in this course. So I'll go ahead and delete this file. For future controllers, you can add a no‑spec flag to the generate command to generate a controller with no test files. Another nice thing about creating modules and controllers with the CLI is that NestJS takes care of all of the imports. So if we take a look at the app module, you'll see that the SpeakersModule has automatically been registered.

# GET Routes and the Param Decorator
In SpeakersController, let's set up some paths to handle our basic crud operations. NestJS offers a set of decorators that make it easy to handle common tasks like accessing route parameters, reading the request body, and retrieving query string values. Each route handler will begin with a decorator that corresponds to an HTTP verb, like get, as we saw in the app controller. To automatically import get from nestjs/common, you can type @get and then Tab. And as you can see, it adds the import for you. The Get decorator with no argument will respond to the /speakers route. And remember, that's because we've indicated a route prefix in the Controller decorator. This decorator annotates a method you want to run when the route is hit. An incoming get request to /speakers will typically return all speakers. So name the method findAll. What about creating a route handler to fetch a speaker by id? For that, we'll need another get route. But this time, pass a string to indicate that the path has a route parameter. This tells NestJS to expect an id in the request URL. So the path this route will handle is /speakers/id. Next, we'll need to define a method. Call this method findOne. Inside the findOne method, you typically grab the id from the route path and use it to find a specific speaker. In other words, you need to get the value of id and pass it into the findOne method. To access the value of id, use the Param decorator. Param decorates the argument you pass into this method, which we'll call id. And to Param, pass a string indicating which value is to be injected into this method. Then define the type, which for now will be a string. The Param decorator automatically extracts the id value from the route parameter in the request URL, allowing the handler to access and use it within this findOne method. For now, let's simply return the id. And up here in the findAll method, mimic a response by returning a simple speaker object containing a name and an expertise. Go ahead and run your server and head to whatever client you're using to send requests to these routes we've created. Send a get request to /speakers, and the response is the speaker that we created. Now let's send a get request with some kind of id, and we get that id back. So we know that everything is working as expected.

# POST Route and the Body Decorator
A REST API will typically provide a route for creating a new resource. Create a handler for a POST request to /speakers. For this, we'll need a decorator called Post. And when a POST request is sent to the path speakers, we'll call a method called create. To create a new speaker, we need a way to extract the new speaker data from the body of an incoming request. To do that, pass a parameter called speaker to the create method and annotate it with a decorator called Body. The Body decorator tells NestJS to inject the request body into the speaker parameter. NestJS provides ways to validate incoming data before it reaches the route handler, which we'll cover later. But for now, we'll indicate that the parameter is called speaker, and its type will be an object, and the object will contain a name, which will be a string, and an expertise, which will also be a string. And then for now, simply return the speaker. We're passing in a parameter called speaker to the create method, and we're annotating it with the Body decorator. The Body decorator will allow NestJS to take the request body and put it into the speaker parameter so that we can access it and do something with it in the create method. Then we're making sure to define for TypeScript the values that we're expecting to be inside this parameter, which are name and expertise. Inside the create function, we are returning the body of the incoming request, just to make sure that we have hooked up this route correctly. Let's check out what happens if we send a POST request to our application. So I'll change the request type to POST. We'll send that to /speakers. Then I'll select JSON here, and let's send an object with the name and expertise. So we've sent an incoming request with speaker data inside of the request body, and the Nest application has successfully extracted that information and sent it back as a response.

# PUT and DELETE Routes
With an understanding of the Param decorator and the Body decorator, we can complete the basic crud operations for this API by defining a PUT route and a DELETE route. For the PUT route, we'll expect to pull the id from the route path and extract the updated speaker data from the body of the client's request. So use a Put decorator and specify that an id parameter will be part of the path. I'll go ahead and import Put up here, and let's define a method called update. Inside of update, we'll want to use the Param decorator to extract the id. And again, we'll expect the id type to be a string. And as a second parameter, we'll inject the body of the request because we'll expect the client to send in the body of the request the information that they want to use to update a specific speaker resource. So to be able to access this from within this, we'll inject the request body into a parameter called updated. And we'll expect that to be an optional name with the type of string and an optional expertise, which will also be a string. Finally, return the id and the updated speaker. Let's test this out. Grab the speaker object and make some updates. Change the request type to PUT and send a /speakers/some id. And the API returns an updated speaker. For the DELETE route, you'll again need to pull the id from the request parameters. Create a method called delete and use the Param decorator to pull the value of the id parameter from the route and pass it to the delete method. Then for now, return the id of the deleted speaker. Don't forget to import the Delete decorator if you haven't already. Again, what you would typically do with these routes is make a call to a service. But for now, we're keeping it simple. We're making sure that everything is wired correctly. So if I send a delete request to any variable route path, you'll see I get that route parameter back as an id.

# The HTTPStatus Decorator
Oftentimes, when a resource is deleted, you won't want to send back an ID or that resource, but simply a status code that indicates that no content was sent back but that the request was successful. For cases like this, NestJS provides a decorator called HttpCode. To HttpCode, you can manually pass a status code like 204. And now if I send a DELETE request, you'll see that the response body is empty, but the application is sending back a status of 204 No Content. But NestJS also provides a set of predefined constants representing HTTP status codes, which can help your code be a little more readable and a little less error‑prone. So instead of 204 here, you can use a constant called HttpStatus NO_CONTENT. I'll come up here and import HttpStatus, send another request, and you'll see that that works just the same.

# The Query Decorator
What about handling query parameters? Let's say that we had a 3‑day long conference and we wanted to add a schedule day to our speakers object. So let's add a schedule day, and we want to be able to pull that schedule day from the query string. In other words, a client should be able to send a request where they include scheduleDay as a query parameter, passing in some value, like Sally Smith speaks on day 3. To extract the value of scheduleDay from the query string, pass scheduleDay as a parameter into the findAll method and annotate it with the Query decorator. Inside the Query decorator, we'll specify which query string value we want to have access to from inside the findAll method. Finally, for TypeScript, we'll indicate that we expect scheduleDay to be a number. Let's test this out. I'll go to my client, and we'll send a GET request with a scheduleDay that equals 2. Your API should return a new speaker object that includes the value of scheduleDay from the query string. So if I add a 3 here, you'll see scheduleDay is 3. Notice that scheduleDay is a string. You can cleanly convert it to a number with a built‑in NestJS pipe. Pipes transform argument data before it reaches the method. In other words, you can use a pipe to convert the scheduleDay argument to a number before the findAll method is invoked. And you can do that by passing ParseIntPipe as a parameter to the Query decorator. Also remove this string template, send the request again, and you'll see scheduleDay is now a number.

# DTOs and Validation
Delegate Business Logic to a Service
Data validation is the process of checking for invalid or malicious data by making sure incoming requests adhere to certain rules and constraints. That'll be the focus of this part of the course. But first, we need to do a little work to make the speaker route handlers a bit more robust. Controllers typically delegate business logic to services. We're currently returning static data in our controller. Now let's take it a step further by updating the controller to interact with the service. This will help us manage our data more effectively and allow us to write validation. Here, the speaker service I've added is responsible for managing speaker data. While in a real‑world application, this would typically involve interacting with a database, for simplicity, we're using an in‑memory array of objects. The service provides methods to create, retrieve, update, and delete speakers, mimicking how you'd interact with persistent storage. Feel free to pause and explore the file to see how it works. But essentially, it's using JavaScript to manipulate the speaker's array. Update your controller to delegate to this service. The first step is to inject the speaker provider into the controller using the controller's constructor function. Using the constructor avoids the need to create multiple instances of the speaker service in this controller. Instead, for each route, we can use this.speaker to make a call to the corresponding function in the speaker service. Let me show you what I mean. In the findAll method, you can get rid of our parameters and the static data and instead return this.speakersService.findAll. If you take a look at the findAll method in the speaker service, it's simply returning this.speakers. For the route handler to get a speaker by id, we can make a call to speakersService.findOne. Return this.speakersService.findOne, passing in the id. TypeScript is warning us that id needs to be a number. Pass ParseIntPipe to the Param decorator to convert the id to a number. For POST, we can call this.speakersService.create, passing in the speaker. For the PUT route, first use the ParseIntPipe to convert the id parameter to a number. Then make a call to this.speakersService.update, passing in the id and the updated speaker. Finally, for the delete route, convert the id parameter to a number and make a call to this.speakersService.delete, also passing in the id. Let's make sure this is working as expected. I'll make a get request to get all speakers. And great, we returned all of the speakers in the speakers array. Let's try getting a speaker by id. That's working. Now let's try creating a new speaker, updating a speaker, and finally, deleting a speaker.

# Data Validation with Data Transfer Objects (DTOs)
This application has all of its basic crud operations, but notice that we can send virtually anything in the request body and the API will add it to the data array, an empty object, invalid fields, even invalid data types. This is where data validation comes in. Data validation is important for ensuring that incoming data is correctly formatted and meets specific rules before reaching your route handlers, which helps to prevent invalid data and security issues. NestJS validates the structure of incoming data through DTOs, or data transfer objects. A DTO is a class that allows you to define the shape and structure of incoming request data. In the POST route, Body is used to extract data from the body of the incoming request. In the PUT and POST routes, we're providing type definitions for the speaker parameter, but they're not being enforced in any meaningful way. So let's replace the type definition with the DTO. Instead of inline TypeScript, we'll define the parameter in a class called CreateSpeakerDTO. When Body is combined with CreateSpeakerDTO, NestJS automatically ensures that the request body matches the expected format before passing it to the route handler. Let's create the speaker dto class now. Create a folder in your speakers folder called dto. And inside of that folder, create a new file called create‑speaker.dto. In this file, create a class called CreateSpeakerDTO. And now let's define what properties we want the speaker to have. To follow convention, let's make sure that only the D in Dto is capitalized. Inside the class, define the speaker properties. We want a name that will be a string, an expertise that will be a string, and let's add an email, which will also be a string. NestJS provides a collection of class validators that we can use to validate this data. But first, you'll need to install some dependencies. So go ahead and stop your server if it's running and install class‑validator and class‑transformer. Import IsEmail, IsNotEmpty, and IsString from class‑validator. You can use these class validators as decorators. So to name, I'll add the decorator IsNotEmpty and IsString. I'll add the same to expertise. And to email, I can use the decorator IsEmail to ensure that this property is a valid email. After you've defined your CreateSpeakerD,o head back to the speakers controller. We've already replaced the inline TypeScript annotation with the DTO. Now you'll need to import it. By convention, the class should be capitalized. Let me make sure that I do that. Before DTOs will work properly in NestJS, we need to set up a global validation pipe. Pipes and NestJS are used to transform and validate data. It receives a method's argument before the method does and does something to act upon it. For example, the ParseIntPipe converts the string from the route parameter to a number before the findOne method receives id as an argument. By setting up a validation pipe, we can make sure the data is following our constraints before it's passed as an argument to a controller method. Set up the validation pipe globally in main.ts. Configuring a validation pipe globally will ensure that validation is enforced on incoming requests across the application, preventing invalid data from reaching any of the route handlers. In main.ts, just before we start the server, you can use apps.useGlobalPipes. And inside it, instantiate a new validation pipe. Import ValidationPipe from nestjs/common. Now let's see if this works. I'll attempt to send some invalid data to create a new speaker. And as you can see, we get all sorts of errors. Name must be a string, expertise must be a string, email must be an email, and so on.

# ValidationPipe and Whitelisting
There's another type of validation we should quickly address. I have a new speaker with an extra age field here. And if I attempt to post it, you'll see that it is successful. I can currently add any extra fields that I want, which could lead to security issues. You can address that by returning to main.ts and passing whitelist as an option to ValidationPipe. Whitelist true will automatically remove any properties from incoming requests that are not explicitly defined in the DTO. Let's try to post a new speaker with invalid fields again, and you'll see that it just completely removes them. In this way, we're using a DTO to prevent unwanted or extra data from ever being processed.

# Generate a Resource with NestJS CLI
Now that you're familiar with how controllers, services, and DTOs work together, let me introduce you to a huge time‑saver that NestJS provides, and that is creating an entire resource. Let's say for this conference management app you wanted to add a feature to track attendees. Use the Nest CLI command nest generate resource plus the name of the resource. So we'll say attendees. It'll then ask me what transport layer I want to use. I'll choose REST API. And yes, I would like to generate crud entry points. That automatically generates an attendees folder with an attendees module, controller, service, and folder for DTOs and entities. We didn't cover entities in this course, but they're classes used to define the structure of your database tables when using an ORM. NestJS automatically takes care of all of your imports. So if we have a look at the attendees module, you'll see that the controller and service are already imported and that the attendees module is already imported into the app module. In the attendees controller, the attendee service is already injected into the class. And there is scaffolded all of the route handlers for your basic crud operations, and they're already delegating to the attendees service. Also notice that the create and update methods are already utilizing DTOs. And in the dto folder, there's a file for a create‑attendee DTO and an update‑attendee DTO. The ability to create an entire feature like this is incredibly useful for faster development and enforcing best practices.
