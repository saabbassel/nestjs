A Simple NestJS Application
In this course, NestJS: Configuration and Setup, you’ll learn how to create and initialize a new NestJS project using the Nest CLI. First, you’ll explore using the Nest CLI and how to decide which options to choose. Next, you’ll discover the main conventions that NestJS uses for each directory and file. Finally, you’ll learn how to structure your NestJS application to follow best practices. When you’re finished with this course, you’ll have the skills and knowledge of NestJS configuration and setup needed to start building your own NestJS application.

What Is NestJS?
NestJS describes itself as a framework for building efficient, scalable Node.js server‑side applications, but what does that mean? If you think about how a Node app works, there's some code running on a server that knows how to accept requests and use logic to decide how to respond. Node though doesn't really suggest any strong conventions for how you organize that code. You have a choice to follow a pattern like model‑view‑controller, but you can make any number of decisions as you write your code. Each decision introduces more complexity and the chance for errors, bugs or even just frustration as collaborators need to learn and opt into that approach, and that's where Nest comes in. Nest is like a layer on top of existing frameworks like Express and Fastify that provides some stricter tools and patterns for architecting your application code in a way that's more modular and maintainable than just plain Node and Express. TypeScript is the default language for Nest applications, which also helps encourage writing type‑safe code. Put another way, the back end that you create with NestJS might not result in functionality that looks too different from a plain Node.js back end. You'll still be passing data around via API endpoints and processing that data on the server, but what Nest provides is an opinionated view of how to make that happen, and that's what makes it so useful. You learn the rules, you follow them, you can be reasonably sure that you'll end up not just with a working application, but one that's stable, testable, and that other developers can pick up and join as long as they also know Nest conventions. So let's get started.

How Does a NestJS Application Work?
Nest applications follow the model‑view‑controller pattern, and each specific feature in an application is wrapped inside of a structure called a module. The root file is a TypeScript file called main.ts, and it runs a function called bootstrap that starts the application. This line here creates the application, which by default is an Express application. So you can do Express‑like things with it like listen for requests on a certain port. The app first looks for a module named AppModule. Moving to that app.module.ts file in the same directory as main.ts, we can see individual feature modules loaded. This basic application is a simplified version of a back‑end API for a concert ticket company. There's two features here, one called Tickets that can be used to get information about the events that are available to purchase, and one called Cart that's a simplified version of logic for a shopping cart to put those tickets in before purchasing them. Now since these are all just TypeScript files and classes, there needs to be a way to differentiate them, and Nest uses helper functions called decorators for that. Decorators start with an @ symbol followed by a word, usually capitalized. This decorator here defines a module. Since we're looking at this application at a high level right now, I'm going to skip over some of the details, but this app module imports two feature modules called Tickets and Cart. In addition to modules, two of the most common files in a Nest application are controllers and services. Controllers in Nest are responsible for handling requests and responses. If you're comparing them to plain Node and Express, this is the place that you define routes that clients will call. The functions that get called from those routes are the business logic of the application, so that code belongs in a service. Since this is a simple example, I'm hardcoding the ticket data directly in the service instead of using the service to load it from a database or other data store. The data shape is defined by a ticket model, which is just a TypeScript interface. If I drew this out as an architectural diagram, it would look like this. AppModule imports the TicketsModule, and the TicketsModule includes a model, controller, and service. Let's flip over to the CartModule. This structure should be a familiar pattern. There's a CartModule that again loads a Controller and a Service. The controller defines a few routes. This time there's a Post and Delete route in addition to Get routes. And these routes call functions in the CartService. This time though, that CartService depends on the TicketsService. For that to happen, the CartModule needs to import the TicketsModule, and the CartService reads TicketsService to be able to retrieve information about just one ticket. There's a cart‑item.model included too, and this one imports the ticket.model since the data that a cart stores is Ticket data. If I update that architecture diagram now, there's a little more happening. The AppModule is loading the CartModule, but the CartModule is also importing the TicketsModule to be able to access that TicketsService. By following Nest conventions, the module loader will make sure all of these play nice together. Now before we move on, let's run this application real quick and try out a few requests. I'll use the command npm run start to start the application. And then I'll use the rapid API VS Code extension to make some test requests for the tickets and cart routes. I've already got those added to the extension to save time. When I request localhost:3000/tickets, I can see that tickets are returned from the data store. If I make a POST request for /cart/1, that should add that ticket to the cart. I'll call it again so there's two tickets in there. Then I'll call /cart with no parameters, and I should see both tickets in that cart. If I want to remove one of them, I can make a delete request and pass the cart item ID as a parameter. Then when I make a GET request for /cart, I can see that there's correctly only one item left in there.

NestJS Project Structure
A basic Nest application will follow a project structure that looks like this. There will be several different configuration files, a main.ts file and files that are specific to your application code. Let's talk about them in that order. This project uses the Node Package Manager, or npm, so the package.json file is where a list of dependencies, test configuration, and run scripts are stored. Nest projects are written in TypeScript, so tsconfig.json is where TypeScript gets configured. Eslint is the default code linter that can be run with the command npm run lint, and this is the place where you can define those linter rules. Finally, prettierrc is where to configure the Prettier code formatter. The nice thing is that a default configuration for each of these is provided, and it's not necessary to edit those files unless you need to change that default. Now if you're not sure if you do need to change them, then just leave them as is. There's a tool that I'll show you how to use soon called the Nest CLI, and this last config file sets the options for that. The default is that this file sets the project root to a folder named src, so let's look in there next. The src directory contains the main.ts file, as well as the initial app.module. Together, these two files are the main entry point of a Nest application. Any other application code you write also goes in that src folder, but it's common to organize it. Here I've taken the two main features, tickets and cart, and created directories for any code that's related to those features. In this simple example, that includes a module, controller, service, and model definition. Now look, I get that it's tough to talk about best practices before you've had a chance to build anything, but I'm going to share a few ideas that you can use as a guide while you learn. First, when creating a module, stick to one module per feature. You technically can put all of the ticket and cart logic in just one module controller and service, but by following the convention of separating them, your code will become easier to understand, test, and maintain. You should also make one folder per module and keep all of the files related to that module in the same folder. This includes those controllers, models, services, and any other files that are related to the feature that that module represents. Those files should follow the same naming and capitalization scheme. And finally, any global settings belong in main.ts. If it's not global, put it in one of the feature modules. There's more that's going to be said in other courses in this path, but in addition to the general project structure of a Nest application, here's the important things to have in your head right now. Nest applications follow a model‑view‑controller pattern. Controllers handle HTTP requests, services handle business logic, models define the structure of data in code, and modules are used to group these controllers, models, and services by the feature that they're responsible for.

Create a New NestJS Application with the Nest CLI
Generate Code Templates with the Nest CLI
That ticket site I just showed you was created with a tool called the Nest CLI. This is an npm package that includes a bunch of useful command‑line tools for working with Nest applications. It should be installed globally. So if you already have Node and npm installed, type npm install ‑g at @nestjs/cli. Then to create a brand‑new project, you just type nest, new, and the project name. I'll call this one ticket‑site. The CLI will prompt you to choose a package manager. Right now I'll stick with npm. This generated all of the config files, main.ts, and the app.module. The default project includes a simple controller and service, but it's fine to delete that and remove it from the app.module options. Let's recreate the structure of ticket‑site using the CLI. There's a file generator with a nest generate command that can be used to create a ton of different file types, which Nest calls schematics. The Nest docs list all of the available schematics, but for this simple example, we'll just need module, controller, and service. I'll start with nest generate module and pass it the name tickets. That not only generates the tickets module, but it also creates and names the folder and imports that module into app.module. The terminal also gives a helpful list of what changes were performed in the codebase. Next, let's run nest generate controller and again pass the name tickets. That generates the controller file, but it's also smart enough to put it in the same folder and even import it into the module. Another reason to file Nest conventions to name everything the same. The CLI is looking for that naming scheme to know where to generate the files. Next, the service with nest generate service tickets. And finally, the model. A model isn't actually a schematic that's available, so I'll manually create that file with the name ticket.model.ts. I'm going to jump ahead and run the commands to create the CartModule too, and I'll copy in all the code to get us back to a working back end.

Run and Build with the Nest CLI
There's CLI commands for running the application too. Nest start is the main command to start the application, but it's also common to use an npm script instead of Nest directly. In fact, if you look at the scripts in the generated package.json file, the start script actually just calls nest start. It's helpful when writing code to load in watch mode with nest start ‑‑watch or the npm version, which would be npm run start:dev. In watch mode, the application will reload every time I make a change to anything in the src folder. Nest build or npm run build compiles the application down to the path defined in tsconfig.json, which by default is a folder named dist. There's a lot more commands that you'll need as you learn different parts of the Nest framework, so check out the CLI docs if you want a preview of those. The only other one I'm going to point out right now is ‑‑dry‑run or just ‑d. Adding this flag to any Nest CLI command will give you a report of what would've happened if you ran it for real. This is useful as a quick check to make sure the command you're running is doing what you expect it to do before it makes any real edits.

Configuration with ConfigModule
Read Environment Variables with ConfigModule
We've got a simple back end running, but there's a few things that are hard coded that ideally we'd want to set in an environment variable. Now rather than directly load environment files though, Nest delegates that to a package called config that among other things includes the .env library. I'll install it now with npm install @nestjs/config. Once that's added, I can import a special config module. There's a few different ways to use config. So first I'll use it at the root of the application in app.module. Inside of that forRoot method, I can set some options like envFilePath where I can define an array of strings that are paths to my local env files. Note that the root path is not src. It's one level above that, the same directory that holds all of the TypeScript and other config files. So writing .env as the env path means that you need a .env file in that root folder. I'll make that right now, and I'll add an environment variable named PORT and set it equal to 4200. Like with other modules, the logic for reading that environment variable data comes from a service. This one's called ConfigService. Let's use ConfigService now to read that PORT environment variable and use that in main.ts. I just need to import ConfigService from nestjs/config, and then I'll write this line to get a copy of that ConfigService object. I can read that port number with configService's get method. The value I pass into that get method needs to match the environment variable name in the .env file. Since this is TypeScript and strict null checks is on by default, I also have to provide a fallback value so the TypeScript compiler doesn't error. I'll use 4201, so it'll be more obvious if something went wrong. I'll run this all again and confirm that the application is now running on port 4200, which means this ConfigService is working.

Centralize Configuration Data
And once you have multiple values to load from an env, it may make sense to pull that logic into a TypeScript file instead of directly writing it in the app.module. I'll create a folder named config and put configuration.ts in there. And from that file, I'll export key pairs that contain those environment variable values. I also need to set those fallback values whenever I read from the environment variables. Then back in app.module, I can import that configuration file and use the load option to pass that to the ConfigModule. I'm also going to change the way I'm reading that port value. Since I'm sending it in the configuration file with the key of lowercase port, I want to read from that lowercase value in the ConfigService. To keep the TypeScript compiler happy though, I'll first need to check if that value is set. Now Nest provides an alternative get method called getOrThrow that can help. Like the name suggests, if the value is found, get is called to retrieve it, and if not, an error will throw that will stop execution, and that keeps TypeScript happy. Let's stop and start the application again to make sure this is working, and great it is. Let's add a few more environment variables and update that configuration file to make them all available. I'll add a MAX_CART_ITEMS value that can be used to limit the amount of tickets that are added to a cart and a DATE_FORMAT value that I can use to transform the way date values are displayed. Then I'll update my configuration object to read the values in that env file into an object. Finally, I'll use the ConfigService throughout the application wherever those values are needed. Starting with the cart, I'll import ConfigService. I want this maxCartItems value to be available everywhere in the service, so I'll create a property on the CartService object and set that property in the constructor using the ConfigService object that I also injected into the constructor. Now I can use that variable in the addToCart method. I'll check if the current cart length is greater than or equal to the max number of items. And if it is, I'll throw an exception to prevent the rest of this method from running. Over in the TicketsService, I'll import ConfigService the same way that I did in the cart, but this time I'll put that dateFormat into a property. And then I can use that property to change the way this date gets returned from the service method. I've installed the moment library to help with that logic. I also need to set a key named isGlobal to true. That will mean that I don't need to reimport ConfigModule in every other module in order to access it. In one way, that kind of goes against the idea of Nest trying to isolate everything into modules, but environment variables are unique in that you probably do want them accessible everywhere. Now when I run the application again and try this out, I can only add three items to the cart before I get an error. And when I request that single ticket date, I can see that the date's correctly formatted.

Environment and Feature-based Configuration
There may be situations where you have common shared environment variables and separate environment‑specific data. For example, imagine that all environments share the date format string, but the PORT and MAX_CART_ITEMS are different between staging and production environments. To start setting that up, I'll break the single env file into three files, one for staging, one for production, and one for shared variables. Then in AppModule, I can pass the shared env as the first envFilePath and dynamically detect the current environment from the NODE_ENV variable for the second. Let's try it. I'll start the application in staging mode, which should mean that it's accessible on port 3000 and not port 4200. Making a request on port 3000 confirms that's working as expected. Notice also that the date is formatted according to that string from the environment variable. That's because that format date value is being set in the shared env, which is always being loaded regardless of which node env the application started with. And right now I'm using the environment to decide which variables to load, but another option in Nest is feature‑specific configuration. For example, I'm loading this maxCartItems config at the root level of the application, but it only applies to the CartModule. I'll add a new cart‑configuration.ts file and pull the maxCartItems out of the main config and into this one. Then in the CartModule, I'll import ConfigModule and cartConfiguration. And then in the imports, instead of using forRoot, I'll use forFeature and pass it that cart‑configuration. None of the other code has to change. The CartService will still pull in the ConfigService and read the value from there, but the way we're creating that configuration is now scoped directly to the CartModule. Later on as this application grows, isolating that config in this module will make the code easier to test and maintain, so it's a good idea to load feature‑specific configuration like this. To summarize, I've shown you three different ways to use the ConfigModule, in the app.module with forRoot with a single env file, in the app.module with forRoot with logic to serve up different env files based on the environment the app has started with, and a per‑feature module with forFeature. And the configuration that you choose is largely going to depend on how you architect your application, but it's good to know that we've got options. Now that's it for this course, but make sure you check out the Nest.js Foundation's course next before the rest of the courses in the path, and thanks for watching.
